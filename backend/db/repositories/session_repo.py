"""
session_repo.py — Call Session Repository
==========================================
Handles all database operations for call sessions.

A "session" represents one complete call from start to finish.
When a user clicks "Start Call" → a session is created.
When they hang up → the session is ended and duration is calculated.

Collection name in MongoDB: "sessions"
"""

from datetime import datetime
from typing import Optional
from db.mongo import get_db
from db.models import Session, SessionStatus
from core.logger import logger
from core.exceptions import DatabaseError


# Name of the MongoDB collection where sessions are stored
COLLECTION = "sessions"


async def create_session(session_id: str) -> Session:
    """
    Create a new session when a call starts.

    Args:
        session_id: Unique ID for this session (generated by the WebRTC route)

    Returns:
        Session: The newly created session object

    Example:
        session = await create_session("sess-abc123")
        print(session.status)  # "active"
    """
    try:
        # Create session object with ACTIVE status
        session = Session(
            id=session_id,
            status=SessionStatus.ACTIVE
        )

        # Save to MongoDB
        db = get_db()
        await db[COLLECTION].insert_one(session.model_dump())

        logger.info("Session created | id={}", session_id)
        return session

    except Exception as e:
        logger.error("Failed to create session: {}", str(e))
        raise DatabaseError(f"Failed to create session: {str(e)}")


async def end_session(
    session_id: str,
    status: SessionStatus = SessionStatus.ENDED
) -> Optional[Session]:
    """
    Mark a session as ended and calculate its duration.

    Args:
        session_id: The session to end
        status: Final status — ENDED (normal) or ERROR (crashed)

    Returns:
        Session: The updated session, or None if not found

    Example:
        session = await end_session("sess-abc123")
        print(session.duration_seconds)  # 300 (5 minutes)
    """
    try:
        db = get_db()
        now = datetime.utcnow()

        # First, get the session to calculate duration
        doc = await db[COLLECTION].find_one({"id": session_id})
        if not doc:
            logger.warning("Session not found for ending | id={}", session_id)
            return None

        # Calculate how long the call lasted
        started_at = doc.get("started_at", now)
        duration_seconds = int((now - started_at).total_seconds())

        # Get message count for this session
        message_count = await db["messages"].count_documents(
            {"session_id": session_id}
        )

        # Update the session in MongoDB
        update_data = {
            "ended_at": now,
            "duration_seconds": duration_seconds,
            "status": status.value,
            "message_count": message_count
        }

        await db[COLLECTION].update_one(
            {"id": session_id},
            {"$set": update_data}
        )

        logger.info(
            "Session ended | id={} duration={}s messages={}",
            session_id, duration_seconds, message_count
        )

        # Return the updated session
        updated_doc = await db[COLLECTION].find_one({"id": session_id})
        return Session(**updated_doc) if updated_doc else None

    except Exception as e:
        logger.error("Failed to end session: {}", str(e))
        raise DatabaseError(f"Failed to end session: {str(e)}")


async def get_session(session_id: str) -> Optional[Session]:
    """
    Get a session by its ID.

    Args:
        session_id: The session to look up

    Returns:
        Session: The session object, or None if not found
    """
    try:
        db = get_db()
        doc = await db[COLLECTION].find_one({"id": session_id})
        return Session(**doc) if doc else None
    except Exception as e:
        raise DatabaseError(f"Failed to get session: {str(e)}")
